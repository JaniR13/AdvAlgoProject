\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

%opening
\title{Part 3: Bayesian Optimization of the flexible Job Shop Scheduling Problem}
\author{Group 06 \\ 
\small Janette Rounds \\ \small David Rice \\ \small Mitch Vander Linden}

\begin{document}

\maketitle

(NOTE: this is just a sample outline, and you are free to deviate from this 
format).

\section{Introduction}
The following algorithm attempts to find an optimized way to schedule the Job-shop Scheduling Problem (JSP) in a more flexible manner called the flexible Job-shop Scheduling Problem (fJSP). Due to the problem being an NP-Hard solution, the algorithm takes advantage of hybrid evolutionary algorithms that use particle swarm optimization and basian network structuring to learn the optimal relationships between machine, task, and objective function. 

The metrics of the algorithm's success in \cite{sun2015bayesian} compare the algorithm run on the following seven environments:
\begin{enumerate}
	\item Genetic Algorithm (GA)
	\item Binary Genetic Algorithm (Binary GA)
	\item Differential Evolutionary Algorithm (DE)
	\item Particle Swarm Optimization (PSO)
	\item Particle Swarm Optimization with Adaptive Grouping Differential Evolution Algorithm (SaNSDE)
	\item Cooperative Coevolution Group (CCPSO)
	\item Bayesian Grouping (CCBhEA) 
\end{enumerate}
where CCBhEA had the most optimal max, mix, and mean time to compute for all scalings of the problem.

\section{Motivation}
The Job-Shop Scheduling Problem (JSP) is an NP-Hard problem in computer science\cite{cheng1996tutorial}. Let us imagine we have a set of machines and a set of jobs to be completed. Each job is a set of operations and the operation order is fixed. In the classical formulation of JSP, each operation has a fixed processing time, and a required machine. However, these authors used the flexible job-shop scheduling problem (fJSP) that assumes that one machine can perform multiple kinds of operation, and as such, there is no fixed processing time \cite{sun2015bayesian}. There are several potential constraints we could use including: a job does not visit the same machines twice; there are no precedence constraints among operations of different jobs; operations can not be interrupted; etc. Both JSP and fJSP are minimization problems, that is, we generally want to minimize the overall time to completion of all the jobs. As we stated before, there is no way to solve this problem in less than exponential time. Therefore, there are several algorithms we can use to approximate the solution. The authors combined Bayesian Optimization and Evolutionary Algorithms approaches to approximate a solution for the fJSP. 

\section{Algorithm}
Provide pseudocode for the algorithm that your team is investigating.  Provide 
pseudocode for the algorithm, and be sure to 

\begin{algorithm}\caption{\textsc{AwesomeAlgorithm}}
 \begin{algorithmic}[1]
   \State {\bf Input:} TODO:list input
   \State {\bf Output:} TODO:list output\\
   
   \State $k \gets \textsc{Random}(0,10)$
   \If{$n=0$}
	\While{$i < k$}
	\State $a[i] \gets b[i]$
        \EndWhile\\
~~~~~~\Return $a$
   \Else\\
   ~~~~~~\Return $b$
   \EndIf
 \end{algorithmic}
\end{algorithm}

\section{Analysis}
Optional: you are welcome to provide a brief proof of correctness or a 
running time analysis of the algorithm.  The difficulty of doing this will, of 
ocurse, depend on your algorithm.

\section{Discussion}
Conclude with a discussion.  Things that you might want to consider to put in 
the discussion (or maybe in their own sections) include: what are some variants 
of this algorithm? Where can this algorithm be applied?  What improvements can 
be made to this algorithm (perhaps commenting on experimental results of the 
original paper)?  Has there been follow-up work (trace the paper's citations in 
google schoolar!)

\end{document}
